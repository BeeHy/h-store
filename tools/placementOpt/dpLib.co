class DPData {
	range _Clusters;
	range _Sites;
	int _siteCapacity;
	DPPartition[] _partitions;
	DPCost _cost;
	
	DPData(range Clusters, range Sites, int siteCapacity, DPPartition[] partitions, DPCost cost){
		_Clusters = Clusters;
		_Sites = Sites;
		_siteCapacity = siteCapacity;
		_partitions = partitions;
		_cost = cost;
	}
	
	range Nodes() {return _Clusters;}
	range NodeSites() {return _Sites;}
	range Partitions() {return _partitions.getRange();}
	int getSiteCapacity() {return _siteCapacity;}
	DPPartition[] getPartitions() {return _partitions;}
	DPCost getCost() {return _cost;}
}

class DPPartition {
	float _heat;
	int _size;
	
	DPPartition(float heat, int size){
		_heat = heat;
		_size = size;
	}
	
	float getHeat() {return _heat;}
	int getSize() {return _size;}
}

class DPCost {
	float _nodeFactor;
	float _siteFactor;
	float _networkFactor;
	float[,] _cost;
	
	DPCost(float siteFactor, float nodeFactor, float networkFactor, float[,] cost){
		_nodeFactor = nodeFactor;
		_siteFactor = siteFactor;
		_networkFactor = networkFactor;
		_cost = cost;
	}
	
	float getSiteFactor() {return _siteFactor;}
	float getNodeFactor() {return _nodeFactor;}
	float getNetworkFactor() {return _networkFactor;}
	float[,] getAffinity() {return _cost;}
	
	float[,] getSiteCost() {return scaleCostMatrix(_siteFactor);}
	float[,] getNodeCost() {return scaleCostMatrix(_nodeFactor);}
	float[,] getNetworkCost() {return scaleCostMatrix(_networkFactor);}
	
	float[,] scaleCostMatrix(float scale){
		float newMatrix[_cost.getRange(0),_cost.getRange(1)];
		forall(i in _cost.getRange(0), j in _cost.getRange(1)){
			newMatrix[i,j] = scale*_cost[i,j];
		}
		return newMatrix;
	}
	
	//void print(ostream out) {out << endl;}
}

function DPData readFile(string fileLoc){
	ifstream input(fileLoc);

	int clustersNb = input.getInt();
	int sitesNb = input.getInt();
	int partitionsNb = input.getInt();
	int siteCapacity = input.getInt();
  
	float nodeFactor = input.getFloat();
	float siteFactor = input.getFloat();
	float clusterFactor = input.getFloat();
	
	
	
	range Partitions = 0..partitionsNb-1;
	DPPartition partitions[Partitions];
	forall(p in Partitions){
		float heat = input.getFloat();
		int size = input.getInt();
		partitions[p] = new DPPartition(heat, size);
	}
	
	float affinityMatrix[Partitions,Partitions];
	forall(p1 in Partitions, p2 in Partitions){
		affinityMatrix[p1,p2] = input.getFloat();
	}
	
	DPCost cost = new DPCost(nodeFactor, siteFactor, clusterFactor, affinityMatrix);
	range Clusters = 0..clustersNb-1;
	range Sites = 0..sitesNb-1;
	
	return new DPData(Clusters, Sites, siteCapacity, partitions, cost);
}

function void printSolution(set{int}[,] solution, DPData data){
  range Partitions = data.Partitions();
  range Nodes = data.Nodes();
  range Sites = data.NodeSites();

  DPPartition[] partitions = data.getPartitions();
  
  float heat[n in Nodes, s in Sites] = sum(p in solution[n,s]) partitions[p].getHeat();
  float cap[n in Nodes, s in Sites] = sum(p in solution[n,s]) partitions[p].getSize();
  
  float[,] siteCost = data.getCost().getSiteCost();
  float[,] nodeCost = data.getCost().getNodeCost();
  float[,] networkCost = data.getCost().getNetworkCost();
  
  boolean sameNode[Partitions, Partitions] = false;
  boolean sameSite[Partitions, Partitions] = false;
  forall(n in Nodes){
    set{int} np();
    forall(s in Sites){
      np = np union solution[n,s];
      forall(p1 in solution[n,s], p2 in solution[n,s]){
        sameSite[p1,p2] = true;
      }
    }
    
    forall(p1 in np, p2 in np){
      sameNode[p1,p2] = true;
    }
  }
  
  /*
  forall(p1 in Partitions, p2 in Partitions : siteCost[p1,p2] > 0.0){
    cout << p1 << " -> " << p2 << " : " <<  siteCost[p1,p2]  << " , " << sameNode[p1,p2] << " , " << sameSite[p1,p2] << endl;
  }
  */
  
  float commCost = 0;
  forall(p1 in Partitions, p2 in Partitions : siteCost[p1,p2] > 0.0){
    if(sameSite[p1,p2]){
      commCost += siteCost[p1,p2]; 
    } else if(sameNode[p1,p2]){
      commCost += nodeCost[p1,p2];
    } else {
      commCost += networkCost[p1,p2];
    }
  }
  
  cout << "Solution:" << endl;
  cout << "  Nodes:" << endl;
  forall(n in Nodes){
    cout << "    " << n << " Cap: " << (sum(s in Sites) cap[n,s])/data.getSiteCapacity() <<" H: " << sum(s in Sites) heat[n,s] << endl;
  }
  cout << "  Sites:" << endl;
  forall(n in Nodes, s in Sites){
    cout << "    " << n << "-" << s << " : " << solution[n,s] << " C: " << cap[n,s] <<" H: " << heat[n,s] << endl;
  }
  cout << "Comm Cost: " << commCost << endl;
}

/*
1 2 4 10000000 2
1 100 10000 
0.222210605743793 49785472487
0.29125794339845634 49785472487
0.249488622416975 49785472487
0.23704282844077565 49785472487
1.0 0.851270553064275 0.8579139677794386 0.8802524497591763 
0.8163201985727583 1.0 0.8482004343779088 0.8685231151101458 
0.8686777604721698 0.8763013361750963 1.0 0.8669563078940897 
0.7826874825759688 0.8898104265402843 0.7697936994703094 1.0
*/