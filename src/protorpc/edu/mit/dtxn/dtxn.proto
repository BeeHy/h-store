package protodtxn;
option java_package = "edu.mit.dtxn";

// TODO: Rename this EngineFragment
message Fragment {
    required int64 transaction_id = 1;
    required bytes work = 2;

    // If true then the fragment must be undoable using a call to Finish.
    required bool undoable = 3;

    // PAVLO: Attach extra info for the txn
    optional bytes payload = 4;
}

// TODO: Rename this EngineFragmentResponse
message FragmentResponse {
    enum Status {
        /** Execution completed successfully. */
        OK = 0;
        ABORT_USER = 1;
        ABORT_DEADLOCK = 2;
        ABORT_MISPREDICT = 5;
    };

    required Status status = 1;

    // Contains the result if status == OK, or an error description if status == ABORT_USER.
    // Note: this field is required, so set it to be empty if it should be ignored.
    required bytes output = 2;
}

// TODO: Rename this EngineFinish?
message FinishRequest {
    required int64 transaction_id = 1;
    required bool commit = 2;
    // PAVLO: Attach extra info for the txn
    optional bytes payload = 3;
}

// TODO: Rename this EngineFinishResponse?
message FinishResponse {
    //required bool committed = 1;
    optional bytes payload = 1;
}

service ExecutionEngine {
    /** Execute a work unit, possibly with an undo buffer and possibly using locks. Returns OK if
    the work unit committed. If this returns ABORT_USER, the work unit aborted and the caller should
    called applyUndo to undo any effects of the transaction. In both the OK and ABORT_USER cases, 
    output will contain valid data. This can only return BLOCKED if transaction is not null. This
    indicates that the work unit was unable to obtain some lock it required. It must be re-executed
    at some point in the future. When it is re-executed, it must either avoid duplicate actions by
    storing data in output or undo, or must be idempotent.
    
    If undo is null, no undo data is required.
    If transaction is not null, undo must not be null. This indicates locks are to be acquired via
    transaction. */
    // TODO: Originally, there was one undo object per work unit. Then I changed it to be one undo
    // object per transaction. However, the optimistic concurrency control scheduler may want to
    // undo just ONE work unit, to avoid redoing extra work. Which is better?
    rpc Execute (Fragment) returns (FragmentResponse);

    // Undo a transaction using the given undo buffer. The undo buffer should be freed after this
    // returns. The caller will ensure that undo buffers are applied in the right order.
    rpc Finish (FinishRequest) returns (FinishResponse);
}


// Describes a single round of work performed by the coordinator as part of a new or existing
// transaction.
message CoordinatorFragment {
    // Specifies the work to be performed at a single partition.
    message PartitionFragment {
        required int32 partition_id = 1;
        required bytes work = 2;
    }

    // Transaction id that is local for this connection.
    required int64 transaction_id = 1;

    // Set of partitions to send work to. A partition can appear only once in this list.
    repeated PartitionFragment fragment = 2;

    // If true, this is the final fragment for this transaction and the active set is empty.
    optional bool last_fragment = 3 [default = false];

    // After this fragment, the partitions in this list have no more work as part of this
    // transaction. It is an error to to include a partition in this list that has already been
    // excluded.
    repeated int32 done_partition = 4;

    // PAVLO: Attach extra info for the txn
    optional bytes payload = 5;
}

message CoordinatorResponse {
    message PartitionResponse {
        required int32 partition_id = 1;
        required bytes output = 2;
    }

    // Transaction id that is local for this connection.
    required int64 transaction_id = 1;

    required FragmentResponse.Status status = 2;

    // Set of partitions with responses.
    repeated PartitionResponse response = 3;
}

service Coordinator {
    /* Begin or continue executing a distributed transaction by distributing the work described in
    the CoordinatorFragment. Returns all the responses in a single CoordinatorResponse message.
    Only a single "round" can be active at once.

    All transactions must be completed by calling Finish(), even though in some cases it is not
    possible to change the transaction's outcome (single partition "finished" transactions).

    All transactions start by including all partitions. The "active partition set" can be shrunk in
    order to optimize execution (important for ordered execution). The active set can never grow.

    Single partition transactions: either a single round of work or multiple rounds sent to a
    single partition. In either case, the partition itself manages the commit so this avoids 2PC
    and avoids blocking (for the "deterministic" scheduling).
    */
    rpc Execute (CoordinatorFragment) returns (CoordinatorResponse);

    // Finishes an active transaction. All transactions must be finished by calling this method.
    rpc Finish (FinishRequest) returns (FinishResponse);
}


/* A message sent directly to the partition. Designed to replace the original DTXN protocol.
Don't confuse this message
TODO: Rename this Fragment.
*/
message DtxnPartitionFragment {
    // Must be *globally* unique. Typically this requires assigning client ids.
    required int64 transaction_id = 1;

    // Describes if this transaction should be committed or not 
    enum CommitState {
        // more fragments are possible (multi-round transaction): this blocks
        OPEN = 1;
        // After this fragment, commit the local transaction (single partition)
        LOCAL_COMMIT = 2;
        // Prepare to commit this transaction as 2PC (multi-partition)
        PREPARE = 3;
    };

    // The state of the transaction after this fragment.
    required CommitState commit = 2;

    // The work unit passed to the execution engine.
    required bytes work = 3;

    // PAVLO: Attach extra info for the txn
    optional bytes payload = 4;
};

/** Wraps an ExecutionEngine, providing concurrency control.

This is an "internal" RPC interface. */
service Partition {
    /** Execute a fragment. */
    rpc Execute (DtxnPartitionFragment) returns (FragmentResponse);

    /** Commit or abort a transaction that was prepared for two-phase commit. */
    rpc Finish (FinishRequest) returns (FinishResponse);
};
