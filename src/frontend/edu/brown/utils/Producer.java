package edu.brown.utils;

import java.util.Collection;
import java.util.HashSet;
import java.util.concurrent.atomic.AtomicBoolean;

import org.apache.log4j.Logger;
import org.voltdb.utils.Pair;

import edu.brown.utils.LoggerUtil.LoggerBoolean;

/**
 * 
 * @author pavlo
 *
 * @param <T> The input type from the given Iterable
 * @param <U> The type of object that will generated by transform and queued at the Consumers
 */
public abstract class Producer<T, U> implements Runnable {
    private static final Logger LOG = Logger.getLogger(Producer.class);
    private static final LoggerBoolean debug = new LoggerBoolean(LOG.isDebugEnabled());
    private static final LoggerBoolean trace = new LoggerBoolean(LOG.isTraceEnabled());
    static {
        LoggerUtil.attachObserver(LOG, debug, trace);
    }

    private final AtomicBoolean queued_all = new AtomicBoolean(false);
    private final Collection<Consumer<U>> consumers = new HashSet<Consumer<U>>();
    private final Iterable<T> it;
    
    public Producer(Collection<Consumer<U>> consumers, Iterable<T> it) {
        this.consumers.addAll(consumers);
        this.it = it;
    }
    
    @Override
    public void run() {
        for (Consumer<U> c : this.consumers) {
             c.setProducer(this);
        } // FOR
        
        int ctr = 0;
        for (T u : this.it) {
            Pair<Consumer<U>, U> p = this.transform(u);
            assert(p != null);
            assert(p.getFirst() != null) : "Null Consumer - " + p;
            assert(p.getSecond() != null) : "Null Object - " + p;
            p.getFirst().queue(p.getSecond());
            if (++ctr % 100 == 0 && debug.get()) 
                LOG.debug(String.format("Queued %d %s objects", ctr, u.getClass().getSimpleName()));
        } // FOR
        this.queued_all.set(true);
        
        // Poke all our threads just in case they finished
        for (Consumer<U> c : this.consumers) c.interrupt();
    }
    
    public abstract Pair<Consumer<U>, U> transform(T u);
    
    public boolean hasQueuedAll() {
        return this.queued_all.get();
    }

}
